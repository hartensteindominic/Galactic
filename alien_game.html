<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alien Frontier: 3D Survivor</title>
  <style>
    :root { color-scheme: dark; font-family: Inter, system-ui, sans-serif; }
    html, body { margin: 0; width: 100%; height: 100%; overflow: hidden; background: #030712; }
    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 4;
      background: rgba(5, 10, 22, 0.65);
      border: 1px solid rgba(91, 223, 255, 0.35);
      border-radius: 12px;
      padding: 10px 14px;
      min-width: 260px;
      backdrop-filter: blur(8px);
    }
    #hud h1 { margin: 0 0 6px; color: #9defff; font-size: 1rem; }
    #hud p { margin: 4px 0; font-size: 0.85rem; color: #d8f7ff; }
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 18px;
      height: 18px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 2px solid rgba(184, 242, 255, 0.9);
      box-shadow: 0 0 18px rgba(100, 228, 255, 0.6);
      pointer-events: none;
      z-index: 3;
    }
    #message {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 14px;
      text-align: center;
      color: #d7f5ff;
      z-index: 5;
      text-shadow: 0 0 12px rgba(29, 196, 255, 0.55);
      font-size: 0.92rem;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="hud">
    <h1>Alien Frontier</h1>
    <p><strong>Move:</strong> W A S D | <strong>Sprint:</strong> Shift</p>
    <p><strong>Aim:</strong> Mouse | <strong>Shoot:</strong> Left Click</p>
    <p><strong>Camera:</strong> Scroll wheel zoom</p>
    <p><strong>Drones destroyed:</strong> <span id="score">0</span>/8</p>
  </div>
  <div id="crosshair"></div>
  <p id="message">Click in the game to lock mouse and control your 3D character.</p>

  <script src="https://unpkg.com/three@0.164.1/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.164.1/examples/js/controls/PointerLockControls.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050915);
    scene.fog = new THREE.Fog(0x050915, 35, 220);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 700);
    camera.position.set(0, 4, 9);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0x8bcfff, 0x101820, 0.8);
    scene.add(hemi);

    const keyLight = new THREE.DirectionalLight(0x87dbff, 1.35);
    keyLight.position.set(35, 58, -8);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(1024, 1024);
    scene.add(keyLight);

    const fill = new THREE.PointLight(0x5dbeff, 0.55, 220, 2.2);
    fill.position.set(-25, 20, 25);
    scene.add(fill);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(420, 420, 90, 90),
      new THREE.MeshStandardMaterial({ color: 0x172538, roughness: 0.93, metalness: 0.05 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    const points = ground.geometry.attributes.position;
    for (let i = 0; i < points.count; i++) {
      const x = points.getX(i);
      const z = points.getZ(i);
      points.setY(i, Math.sin(x * 0.075) * Math.cos(z * 0.065) * 1.6 + Math.sin(z * 0.16) * 0.48);
    }
    ground.geometry.computeVertexNormals();
    scene.add(ground);

    const starsGeometry = new THREE.BufferGeometry();
    const stars = new Float32Array(9000);
    for (let i = 0; i < stars.length; i += 3) {
      stars[i] = (Math.random() - 0.5) * 900;
      stars[i + 1] = Math.random() * 280 + 24;
      stars[i + 2] = (Math.random() - 0.5) * 900;
    }
    starsGeometry.setAttribute('position', new THREE.BufferAttribute(stars, 3));
    scene.add(new THREE.Points(starsGeometry, new THREE.PointsMaterial({ color: 0xb9e6ff, size: 0.82 })));

    const crystalGroup = new THREE.Group();
    const crystalGeometry = new THREE.ConeGeometry(0.9, 4.6, 7);
    for (let i = 0; i < 35; i++) {
      const crystal = new THREE.Mesh(
        crystalGeometry,
        new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(0.54 + Math.random() * 0.19, 0.9, 0.54),
          emissive: 0x0a1f35,
          metalness: 0.45,
          roughness: 0.22
        })
      );
      crystal.position.set((Math.random() - 0.5) * 300, 2.3, (Math.random() - 0.5) * 300);
      crystal.castShadow = true;
      crystal.rotation.y = Math.random() * Math.PI;
      crystalGroup.add(crystal);
    }
    scene.add(crystalGroup);

    const player = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.55, 1.25, 6, 10),
      new THREE.MeshStandardMaterial({ color: 0x4cd4ff, emissive: 0x0f3856, roughness: 0.35, metalness: 0.45 })
    );
    body.castShadow = true;
    body.position.y = 1.25;

    const visor = new THREE.Mesh(
      new THREE.SphereGeometry(0.33, 24, 14),
      new THREE.MeshStandardMaterial({ color: 0xa4f8ff, emissive: 0x12547a, roughness: 0.15, metalness: 0.2 })
    );
    visor.position.set(0, 2.1, 0.35);
    visor.scale.set(1, 0.75, 0.5);
    visor.castShadow = true;

    player.add(body, visor);
    player.position.set(0, 0, 8);
    scene.add(player);

    const controls = new THREE.PointerLockControls(camera, document.body);
    const message = document.getElementById('message');
    document.body.addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', () => message.textContent = 'Mouse locked: move your 3D character and clear the biome.');
    controls.addEventListener('unlock', () => message.textContent = 'Paused. Click to lock controls again.');

    const enemyCount = 8;
    const enemies = [];
    const enemyGeometry = new THREE.IcosahedronGeometry(1.3, 1);
    for (let i = 0; i < enemyCount; i++) {
      const enemy = new THREE.Mesh(
        enemyGeometry,
        new THREE.MeshStandardMaterial({ color: 0x8bff96, emissive: 0x164f15, roughness: 0.32, metalness: 0.48 })
      );
      enemy.position.set((Math.random() - 0.5) * 95, 2.5 + Math.random() * 1.2, (Math.random() - 0.5) * 95);
      enemy.castShadow = true;
      enemy.userData.alive = true;
      enemy.userData.velocity = new THREE.Vector3((Math.random() - 0.5) * 0.045, 0, (Math.random() - 0.5) * 0.045);
      scene.add(enemy);
      enemies.push(enemy);
    }

    const keys = { w: false, a: false, s: false, d: false, shift: false };
    addEventListener('keydown', (e) => {
      if (e.code === 'KeyW') keys.w = true;
      if (e.code === 'KeyA') keys.a = true;
      if (e.code === 'KeyS') keys.s = true;
      if (e.code === 'KeyD') keys.d = true;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = true;
    });
    addEventListener('keyup', (e) => {
      if (e.code === 'KeyW') keys.w = false;
      if (e.code === 'KeyA') keys.a = false;
      if (e.code === 'KeyS') keys.s = false;
      if (e.code === 'KeyD') keys.d = false;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = false;
    });

    const scoreEl = document.getElementById('score');
    let score = 0;
    const raycaster = new THREE.Raycaster();
    addEventListener('mousedown', () => {
      if (!controls.isLocked) return;
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const liveTargets = enemies.filter((enemy) => enemy.userData.alive);
      const hit = raycaster.intersectObjects(liveTargets, false)[0];
      if (!hit) return;
      const target = hit.object;
      target.userData.alive = false;
      target.material.color.set(0x2c3e56);
      target.material.emissive.set(0x050a12);
      target.scale.setScalar(0.34);
      score += 1;
      scoreEl.textContent = score;
      if (score === enemyCount) message.textContent = 'All drones neutralized. Great run!';
    });

    let zoomDistance = 7.5;
    addEventListener('wheel', (event) => {
      zoomDistance += event.deltaY * 0.01;
      zoomDistance = THREE.MathUtils.clamp(zoomDistance, 4.5, 13);
    }, { passive: true });

    const moveVector = new THREE.Vector3();
    const cameraForward = new THREE.Vector3();
    const cameraRight = new THREE.Vector3();
    const toEnemy = new THREE.Vector3();
    const camTarget = new THREE.Vector3();
    const desiredCamPos = new THREE.Vector3();
    const clock = new THREE.Clock();

    function groundHeightAt(x, z) {
      return Math.sin(x * 0.075) * Math.cos(z * 0.065) * 1.6 + Math.sin(z * 0.16) * 0.48;
    }

    function animate() {
      const dt = Math.min(clock.getDelta(), 0.033);
      const t = performance.now() * 0.001;

      if (controls.isLocked) {
        const speed = (keys.shift ? 14.5 : 9) * dt;
        moveVector.set(0, 0, 0);

        camera.getWorldDirection(cameraForward);
        cameraForward.y = 0;
        if (cameraForward.lengthSq() < 1e-5) cameraForward.set(0, 0, -1);
        cameraForward.normalize();

        cameraRight.crossVectors(cameraForward, new THREE.Vector3(0, 1, 0)).normalize();

        if (keys.w) moveVector.add(cameraForward);
        if (keys.s) moveVector.sub(cameraForward);
        if (keys.d) moveVector.add(cameraRight);
        if (keys.a) moveVector.sub(cameraRight);

        if (moveVector.lengthSq() > 0) {
          moveVector.normalize().multiplyScalar(speed);
          player.position.add(moveVector);
          player.rotation.y = Math.atan2(moveVector.x, moveVector.z);
        }
      }

      const floor = groundHeightAt(player.position.x, player.position.z);
      player.position.y = floor + 0.05;
      body.position.y = 1.2 + Math.sin(t * 10) * 0.04;
      visor.position.y = 2.05 + Math.sin(t * 10) * 0.04;

      camTarget.copy(player.position).add(new THREE.Vector3(0, 2.1, 0));
      camera.getWorldDirection(cameraForward);
      desiredCamPos.copy(camTarget).addScaledVector(cameraForward, -zoomDistance).add(new THREE.Vector3(0, 1.15, 0));
      camera.position.lerp(desiredCamPos, 0.12);
      camera.lookAt(camTarget);

      for (const enemy of enemies) {
        if (!enemy.userData.alive) continue;
        enemy.position.add(enemy.userData.velocity);
        enemy.position.y = groundHeightAt(enemy.position.x, enemy.position.z) + 2.8 + Math.sin(t * 2.8 + enemy.id) * 0.7;
        enemy.rotation.x += 0.015;
        enemy.rotation.y += 0.02;

        if (Math.abs(enemy.position.x) > 125) enemy.userData.velocity.x *= -1;
        if (Math.abs(enemy.position.z) > 125) enemy.userData.velocity.z *= -1;

        toEnemy.subVectors(player.position, enemy.position);
        if (toEnemy.length() < 18) {
          enemy.userData.velocity.addScaledVector(toEnemy.normalize(), -0.0022);
          enemy.userData.velocity.clampLength(0.018, 0.085);
        }
      }

      crystalGroup.children.forEach((crystal, i) => {
        crystal.rotation.y += 0.002 + (i % 6) * 0.0005;
        crystal.position.y = 2.2 + Math.sin(t + i) * 0.1;
      });

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    animate();
  </script>
</body>
</html>
