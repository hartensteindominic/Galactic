<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alien Frontier: Survivor</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: Inter, system-ui, sans-serif;
      --bg: #030712;
      --panel: rgba(5, 10, 22, 0.78);
      --border: rgba(91, 223, 255, 0.35);
      --text: #d8f7ff;
      --accent: #9defff;
      --good: #74ff8a;
      --warn: #ffd166;
    }

    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
    }

    .panel {
      position: fixed;
      z-index: 3;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 14px;
      backdrop-filter: blur(8px);
      color: var(--text);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.22);
    }

    #hud {
      top: 12px;
      left: 12px;
      min-width: 320px;
      font-size: 0.9rem;
    }

    #aiPanel {
      right: 12px;
      top: 12px;
      width: min(360px, calc(100vw - 24px));
      font-size: 0.84rem;
    }

    h1, h2, p {
      margin: 4px 0;
    }

    h1 {
      font-size: 1rem;
      color: var(--accent);
    }

    h2 {
      font-size: 0.95rem;
      color: var(--accent);
      margin-bottom: 8px;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 6px 0;
      flex-wrap: wrap;
    }

    .row label {
      min-width: 72px;
      opacity: 0.92;
    }

    input {
      background: rgba(10, 20, 40, 0.8);
      color: var(--text);
      border: 1px solid rgba(157, 239, 255, 0.3);
      border-radius: 8px;
      padding: 5px 7px;
      flex: 1;
      min-width: 120px;
    }

    button {
      background: rgba(18, 95, 118, 0.8);
      color: #e6faff;
      border: 1px solid rgba(157, 239, 255, 0.4);
      border-radius: 8px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    button:hover {
      filter: brightness(1.1);
    }

    #message {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 14px;
      text-align: center;
      color: #d7f5ff;
      z-index: 3;
      font-size: 0.92rem;
      text-shadow: 0 0 8px rgba(29, 196, 255, 0.45);
      padding: 0 10px;
    }

    #aiAdvice {
      margin-top: 8px;
      min-height: 44px;
      border-radius: 8px;
      padding: 8px;
      background: rgba(8, 18, 34, 0.65);
      border: 1px solid rgba(157, 239, 255, 0.2);
      line-height: 1.3;
      white-space: pre-wrap;
    }

    .tiny {
      font-size: 0.75rem;
      opacity: 0.85;
    }

    .stat-good {
      color: var(--good);
      font-weight: 600;
    }

    .stat-warn {
      color: var(--warn);
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div id="hud" class="panel">
    <h1>Alien Frontier</h1>
    <p><strong>Move:</strong> W A S D &nbsp;|&nbsp; <strong>Shoot:</strong> Left Click &nbsp;|&nbsp; <strong>Restart:</strong> R</p>
    <p><strong>Pause:</strong> P &nbsp;|&nbsp; <strong>Auto-AI Pilot:</strong> T</p>
    <p><strong>HP:</strong> <span id="hp">100</span></p>
    <p><strong>Wave:</strong> <span id="wave">1</span> &nbsp; <strong>Destroyed:</strong> <span id="score">0</span></p>
    <p><strong>Enemies alive:</strong> <span id="alive">0</span></p>
    <p><strong>Auto-AI:</strong> <span id="autopilot">OFF</span></p>
  </div>

  <div id="aiPanel" class="panel">
    <h2>AI Tactical Advisor</h2>
    <div class="row"><label for="endpoint">Endpoint</label><input id="endpoint" value="https://api.openai.com/v1/chat/completions" /></div>
    <div class="row"><label for="model">Model</label><input id="model" value="gpt-4o-mini" /></div>
    <div class="row"><label for="apiKey">API Key</label><input id="apiKey" placeholder="sk-... (stored locally in this browser)" type="password" /></div>
    <div class="row">
      <button id="askAiBtn">Ask AI Strategy</button>
      <button id="saveSettingsBtn">Save Settings</button>
    </div>
    <div id="aiAdvice">AI advice will appear here. If API fails, local fallback advice is shown.</div>
    <p class="tiny">Security note: key is kept only in localStorage for this browser profile.</p>
  </div>

  <p id="message">Game loaded. Survive waves and clear enemies. Press R anytime to restart.</p>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hpEl = document.getElementById('hp');
    const scoreEl = document.getElementById('score');
    const waveEl = document.getElementById('wave');
    const aliveEl = document.getElementById('alive');
    const autopilotEl = document.getElementById('autopilot');
    const messageEl = document.getElementById('message');

    const endpointEl = document.getElementById('endpoint');
    const modelEl = document.getElementById('model');
    const apiKeyEl = document.getElementById('apiKey');
    const askAiBtn = document.getElementById('askAiBtn');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    const aiAdviceEl = document.getElementById('aiAdvice');

    function resize() {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
    }
    addEventListener('resize', resize);
    resize();

    const keys = new Set();
    const mouse = { x: canvas.width / 2, y: canvas.height / 2, down: false };

    let stars = [];
    let bullets = [];
    let enemies = [];
    let enemyBullets = [];
    let particles = [];

    let player;
    let score;
    let wave;
    let gameOver;
    let paused;
    let waveCooldown;
    let autopilot;
    let shootCooldown;

    function makeStars() {
      stars = Array.from({ length: 180 }, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        s: Math.random() * 1.8 + 0.2
      }));
    }

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function resetGame() {
      player = { x: canvas.width / 2, y: canvas.height / 2, r: 16, hp: 100, speed: 255, invuln: 0 };
      bullets = [];
      enemies = [];
      enemyBullets = [];
      particles = [];
      score = 0;
      wave = 1;
      gameOver = false;
      paused = false;
      waveCooldown = 0;
      autopilot = false;
      shootCooldown = 0;

      makeStars();
      spawnWave();
      updateHud();
      setMessage('Mission reset. Survive and clear each wave.');
    }

    function setMessage(text) {
      messageEl.textContent = text;
    }

    function updateHud() {
      hpEl.textContent = Math.max(0, Math.ceil(player.hp));
      scoreEl.textContent = score;
      waveEl.textContent = wave;
      aliveEl.textContent = enemies.length;
      autopilotEl.textContent = autopilot ? 'ON' : 'OFF';
      autopilotEl.className = autopilot ? 'stat-good' : 'stat-warn';
    }

    function spawnEnemy() {
      const side = Math.floor(Math.random() * 4);
      let x = 0;
      let y = 0;
      if (side === 0) { x = rand(0, canvas.width); y = -30; }
      if (side === 1) { x = canvas.width + 30; y = rand(0, canvas.height); }
      if (side === 2) { x = rand(0, canvas.width); y = canvas.height + 30; }
      if (side === 3) { x = -30; y = rand(0, canvas.height); }

      const speedScale = Math.min(1 + wave * 0.08, 2.5);
      const fireRate = Math.max(1.4 - wave * 0.08, 0.55);
      enemies.push({
        x,
        y,
        r: rand(12, 17),
        speed: rand(40, 90) * speedScale,
        fireCooldown: rand(0.2, 1.4),
        fireRate
      });
    }

    function spawnWave() {
      const count = 6 + wave * 3;
      for (let i = 0; i < count; i++) spawnEnemy();
      setMessage(`Wave ${wave} started. Enemies detected: ${count}.`);
      updateHud();
    }

    function shootFrom(entity, angle, speed, isEnemy = false) {
      const projectile = {
        x: entity.x,
        y: entity.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1.5,
        r: isEnemy ? 4 : 3.8
      };
      if (isEnemy) enemyBullets.push(projectile);
      else bullets.push(projectile);
    }

    function explode(x, y, color = '#9bffb4', size = 10) {
      for (let i = 0; i < size; i++) {
        particles.push({
          x,
          y,
          vx: rand(-95, 95),
          vy: rand(-95, 95),
          life: rand(0.25, 0.6),
          color
        });
      }
    }

    function applyAutopilot(dt) {
      if (!autopilot || gameOver || paused) return;
      if (enemies.length === 0) return;

      let nearest = null;
      let nearestDist = Infinity;
      for (const enemy of enemies) {
        const d = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if (d < nearestDist) {
          nearestDist = d;
          nearest = enemy;
        }
      }

      if (!nearest) return;

      mouse.x = nearest.x;
      mouse.y = nearest.y;

      const awayX = player.x - nearest.x;
      const awayY = player.y - nearest.y;
      const dangerZone = nearestDist < 170;
      let moveX = 0;
      let moveY = 0;

      if (dangerZone) {
        const mag = Math.hypot(awayX, awayY) || 1;
        moveX = awayX / mag;
        moveY = awayY / mag;
      } else {
        const orbitAngle = Math.atan2(awayY, awayX) + Math.PI / 2;
        moveX = Math.cos(orbitAngle) * 0.75;
        moveY = Math.sin(orbitAngle) * 0.75;
      }

      player.x += moveX * player.speed * dt;
      player.y += moveY * player.speed * dt;

      if (shootCooldown <= 0) {
        const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
        shootFrom(player, angle, 560, false);
        shootCooldown = 0.12;
      }
    }

    function update(dt) {
      if (gameOver || paused) return;

      shootCooldown = Math.max(0, shootCooldown - dt);
      player.invuln = Math.max(0, player.invuln - dt);

      let dx = 0;
      let dy = 0;
      if (!autopilot) {
        if (keys.has('KeyW')) dy -= 1;
        if (keys.has('KeyS')) dy += 1;
        if (keys.has('KeyA')) dx -= 1;
        if (keys.has('KeyD')) dx += 1;

        if (dx !== 0 || dy !== 0) {
          const mag = Math.hypot(dx, dy);
          player.x += (dx / mag) * player.speed * dt;
          player.y += (dy / mag) * player.speed * dt;
        }
      }

      applyAutopilot(dt);

      player.x = Math.max(player.r, Math.min(canvas.width - player.r, player.x));
      player.y = Math.max(player.r, Math.min(canvas.height - player.r, player.y));

      for (const arr of [bullets, enemyBullets]) {
        for (let i = arr.length - 1; i >= 0; i--) {
          const b = arr[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.life -= dt;
          if (b.life <= 0 || b.x < -30 || b.x > canvas.width + 30 || b.y < -30 || b.y > canvas.height + 30) {
            arr.splice(i, 1);
          }
        }
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const ex = player.x - enemy.x;
        const ey = player.y - enemy.y;
        const dist = Math.hypot(ex, ey) || 1;

        enemy.x += (ex / dist) * enemy.speed * dt;
        enemy.y += (ey / dist) * enemy.speed * dt;
        enemy.fireCooldown -= dt;

        if (enemy.fireCooldown <= 0) {
          const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x) + rand(-0.12, 0.12);
          shootFrom(enemy, angle, 280 + wave * 8, true);
          enemy.fireCooldown = enemy.fireRate;
        }

        if (dist < player.r + enemy.r && player.invuln <= 0) {
          player.hp -= 16;
          player.invuln = 0.35;
          explode(player.x, player.y, '#9defff', 14);
        }

        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (Math.hypot(b.x - enemy.x, b.y - enemy.y) < b.r + enemy.r) {
            bullets.splice(j, 1);
            enemies.splice(i, 1);
            score += 1;
            explode(enemy.x, enemy.y, '#74ff8a', 9);
            break;
          }
        }
      }

      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        if (Math.hypot(b.x - player.x, b.y - player.y) < b.r + player.r && player.invuln <= 0) {
          enemyBullets.splice(i, 1);
          player.hp -= 11;
          player.invuln = 0.2;
          explode(player.x, player.y, '#ffd166', 8);
        }
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }

      if (player.hp <= 0 && !gameOver) {
        player.hp = 0;
        gameOver = true;
        setMessage(`Mission failed on wave ${wave}. Press R to restart.`);
      }

      if (!gameOver && enemies.length === 0) {
        waveCooldown += dt;
        if (waveCooldown > 1.1) {
          wave += 1;
          waveCooldown = 0;
          spawnWave();
        }
      }

      updateHud();
    }

    function drawPlayerShip(p) {
      ctx.save();
      const angle = Math.atan2(mouse.y - p.y, mouse.x - p.x);
      ctx.translate(p.x, p.y);
      ctx.rotate(angle);

      const bodyGrad = ctx.createLinearGradient(-p.r, 0, p.r * 1.3, 0);
      bodyGrad.addColorStop(0, '#69a6ff');
      bodyGrad.addColorStop(0.58, '#a2f4ff');
      bodyGrad.addColorStop(1, '#d9feff');
      ctx.fillStyle = bodyGrad;
      ctx.beginPath();
      ctx.moveTo(p.r * 1.35, 0);
      ctx.lineTo(-p.r * 0.9, -p.r * 0.78);
      ctx.quadraticCurveTo(-p.r * 1.35, 0, -p.r * 0.9, p.r * 0.78);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#0b2742';
      ctx.beginPath();
      ctx.ellipse(p.r * 0.1, 0, p.r * 0.35, p.r * 0.26, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = 'rgba(145,235,255,0.7)';
      ctx.beginPath();
      ctx.moveTo(-p.r * 0.1, -p.r * 0.18);
      ctx.lineTo(-p.r * 1.28, -p.r * 0.5);
      ctx.lineTo(-p.r * 0.9, -p.r * 0.08);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(-p.r * 0.1, p.r * 0.18);
      ctx.lineTo(-p.r * 1.28, p.r * 0.5);
      ctx.lineTo(-p.r * 0.9, p.r * 0.08);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = 'rgba(114,241,255,0.65)';
      ctx.beginPath();
      ctx.moveTo(-p.r * 1.12, -p.r * 0.2);
      ctx.lineTo(-p.r * 1.85 - Math.random() * 4, 0);
      ctx.lineTo(-p.r * 1.12, p.r * 0.2);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawAlienUfo(enemy) {
      ctx.save();
      ctx.translate(enemy.x, enemy.y);
      const pulse = Math.sin(performance.now() / 250 + enemy.x * 0.02) * 0.8;

      const domeGrad = ctx.createRadialGradient(0, -enemy.r * 0.5, 1, 0, -enemy.r * 0.45, enemy.r * 1.1);
      domeGrad.addColorStop(0, '#dbffe1');
      domeGrad.addColorStop(1, '#95ffb7');
      ctx.fillStyle = domeGrad;
      ctx.beginPath();
      ctx.ellipse(0, -enemy.r * 0.4, enemy.r * 0.65, enemy.r * 0.48, 0, Math.PI, 0, true);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#63ce7f';
      ctx.beginPath();
      ctx.ellipse(0, 0, enemy.r * 1.1, enemy.r * 0.56 + pulse * 0.04, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#d5ff75';
      ctx.beginPath();
      ctx.arc(0, -enemy.r * 0.42, enemy.r * 0.23, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#102f16';
      ctx.beginPath();
      ctx.arc(-enemy.r * 0.08, -enemy.r * 0.46, enemy.r * 0.05, 0, Math.PI * 2);
      ctx.arc(enemy.r * 0.08, -enemy.r * 0.46, enemy.r * 0.05, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = 'rgba(160,255,191,0.7)';
      ctx.fillRect(-enemy.r * 0.15, -enemy.r * 0.22, enemy.r * 0.3, enemy.r * 0.06);

      for (let i = -1; i <= 1; i++) {
        ctx.fillStyle = `rgba(213,255,117,${0.55 + pulse * 0.08})`;
        ctx.beginPath();
        ctx.arc(i * enemy.r * 0.5, enemy.r * 0.38, enemy.r * 0.1, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawPlasmaBolt(b, enemyShot) {
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(Math.atan2(b.vy, b.vx));
      ctx.fillStyle = enemyShot ? '#ff9a4a' : '#a4f4ff';
      ctx.fillRect(-b.r * 1.2, -b.r * 0.4, b.r * 2.4, b.r * 0.8);
      ctx.fillStyle = enemyShot ? '#ffe2b4' : '#edfdff';
      ctx.fillRect(-b.r * 0.3, -b.r * 0.2, b.r * 1.1, b.r * 0.4);
      ctx.restore();
    }

    function draw() {
      ctx.fillStyle = '#050915';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (const st of stars) {
        ctx.fillStyle = 'rgba(145,214,255,0.13)';
        ctx.fillRect(st.x, st.y, st.s, st.s);
      }

      for (const enemy of enemies) drawAlienUfo(enemy);

      for (const b of enemyBullets) drawPlasmaBolt(b, true);

      for (const b of bullets) drawPlasmaBolt(b, false);

      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 2.5, 2.5);
      }

      const blink = player.invuln > 0 ? (Math.floor(performance.now() / 60) % 2 === 0) : true;
      if (blink) {
        drawPlayerShip(player);
      }

      ctx.strokeStyle = 'rgba(194,247,255,0.75)';
      ctx.beginPath();
      ctx.arc(mouse.x, mouse.y, 9, 0, Math.PI * 2);
      ctx.stroke();

      if (paused) {
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#e8fbff';
        ctx.font = 'bold 30px Inter, system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
      }
    }

    function fallbackAdvice() {
      if (gameOver) return 'Fallback AI: Restart with R, then keep moving diagonally to avoid swarm pressure.';
      if (player.hp < 30) return 'Fallback AI: HP critical. Kite enemies in circles and avoid close collisions.';
      if (enemies.length > 12) return 'Fallback AI: Thin the nearest cluster first, then create distance.';
      return 'Fallback AI: Focus nearest enemy, keep strafing, and avoid stopping in corners.';
    }

    async function askAiStrategy() {
      const endpoint = endpointEl.value.trim();
      const model = modelEl.value.trim();
      const apiKey = apiKeyEl.value.trim();

      if (!endpoint || !model || !apiKey) {
        aiAdviceEl.textContent = `Please fill endpoint, model, and API key.\n${fallbackAdvice()}`;
        return;
      }

      aiAdviceEl.textContent = 'Contacting AI advisor...';

      const state = {
        hp: Math.round(player.hp),
        wave,
        enemiesAlive: enemies.length,
        score,
        autopilot,
        playerPos: { x: Math.round(player.x), y: Math.round(player.y) }
      };

      const payload = {
        model,
        temperature: 0.4,
        messages: [
          { role: 'system', content: 'You are a concise tactical assistant for a top-down survival shooter. Give 2-3 short actionable tips.' },
          { role: 'user', content: `Game state: ${JSON.stringify(state)}. Give immediate survival advice.` }
        ]
      };

      try {
        const res = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`
          },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }

        const data = await res.json();
        const text = data?.choices?.[0]?.message?.content?.trim();
        aiAdviceEl.textContent = text || fallbackAdvice();
      } catch (err) {
        aiAdviceEl.textContent = `AI request failed (${err.message}).\n${fallbackAdvice()}`;
      }
    }

    function saveAiSettings() {
      localStorage.setItem('af_endpoint', endpointEl.value.trim());
      localStorage.setItem('af_model', modelEl.value.trim());
      localStorage.setItem('af_apiKey', apiKeyEl.value.trim());
      aiAdviceEl.textContent = 'AI settings saved locally in this browser.';
    }

    function loadAiSettings() {
      endpointEl.value = localStorage.getItem('af_endpoint') || endpointEl.value;
      modelEl.value = localStorage.getItem('af_model') || modelEl.value;
      apiKeyEl.value = localStorage.getItem('af_apiKey') || '';
    }

    addEventListener('keydown', (e) => {
      keys.add(e.code);
      if (e.code === 'KeyR') resetGame();
      if (e.code === 'KeyP' && !gameOver) {
        paused = !paused;
        setMessage(paused ? 'Paused. Press P to resume.' : 'Resumed.');
      }
      if (e.code === 'KeyT' && !gameOver) {
        autopilot = !autopilot;
        updateHud();
        setMessage(`Auto-AI pilot ${autopilot ? 'enabled' : 'disabled'}.`);
      }
    });
    addEventListener('keyup', (e) => keys.delete(e.code));

    canvas.addEventListener('mousemove', (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });

    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0 || gameOver || paused || autopilot) return;
      mouse.down = true;
      const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
      shootFrom(player, angle, 560, false);
    });

    canvas.addEventListener('mouseup', () => {
      mouse.down = false;
    });

    askAiBtn.addEventListener('click', askAiStrategy);
    saveSettingsBtn.addEventListener('click', saveAiSettings);

    let last = performance.now();
    function loop(now) {
      const dt = Math.min((now - last) / 1000, 0.033);
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    loadAiSettings();
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
